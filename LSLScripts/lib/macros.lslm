$module (
	list VictimsList,
	list FreeVictimsList,
	list DomList,
	list GrabList,
	list RecaptureList,
	list SensorList,
	
	key VictimKey,
	
	integer RlvRestrictionsMenuAvailable,
	
	integer TimerRunning,
	
	string RlvBaseRestrictions,
	
	integer RLV_RELAY_CHANNEL,
	integer RLV_ASK_TIMEOUT,

	integer VICTIMS_LIST_STRIDE,
	
	integer FREE_VICTIMS_LIST_STRIDE,
	
	integer DOM_LIST_STRIDE,
	
	integer GRAB_LIST_MAX_ENTRIES,
	integer GRAB_LIST_STRIDE,
	integer GRAB_LIST_TIMEOUT,
	
	integer RECAPTURE_LIST_MAX_ENTRIES,
	integer RECAPTURE_LIST_STRIDE,
	integer RECAPTURE_LIST_TIMEOUT,
	
	integer DIALOG,
	integer RLV_VICTIM_ADDED,
	integer RLV_VICTIM_REMOVED,
	integer UPDATE_CURRENT_VICTIM,
	
	string BACKBTN,
	key MyUniqueId,
	
	string PROMPT_VICTIM,
	string NO_VICTIM,
	string NEW_LINE,
	string TIMER_NO_TIME,
	
	integer VICTIMS_LIST_RELAY,
	integer VICTIMS_LIST_TIMER,
	
	string RLV_COMMAND_RELEASE,
	string RLV_COMMAND_VERSION
)

// pragma inline
string stringReplace( string str, string search, string replace ) {
	return llDumpList2String(llParseStringKeepNulls( str, [ search ], [] ), replace );
}

// pragma inline
integer getVictimIndex(key avatarUuid) {
	return llListFindList(VictimsList, [avatarUuid]);
}
// pragma inline
integer getFreeVictimIndex(key avatarUuid) {
	return llListFindList(FreeVictimsList, [avatarUuid]);
}
// pragma inline
integer getDomIndex(key avatarUuid) {
	return llListFindList(DomList, [avatarUuid]);
}

// pragma inline
integer getGrabIndex(key avatarUuid) {
	return llListFindList(GrabList, [avatarUuid]);
}

// pragma inline
integer getRecaptureIndex(key avatarUuid) {
	return llListFindList(RecaptureList, [avatarUuid]);
}

// NO pragma inline
addToVictimsList(key avatarUuid, integer timerTime) {
	removeFromVictimsList(avatarUuid);
	removeFromFreeVictimsList(avatarUuid);
	removeFromDomList(avatarUuid);

	if(timerTime>0) {
		timerTime+=llGetUnixTime();
	}
	else if(timerTime<0) {
		timerTime=0;
	}
	VictimsList+=[avatarUuid, timerTime, 0];
	llMessageLinked(LINK_SET, RLV_VICTIM_ADDED, (string)avatarUuid, "");
	//do Relay check and apply restrictions
	sendToRlvRelay(avatarUuid, RLV_COMMAND_VERSION + "|" + RlvBaseRestrictions, "");
	//the timer should be running if there is a victim in the list
	if(!TimerRunning) {
		llSetTimerEvent(1.0);
		TimerRunning=TRUE;
	}
}

// NO pragma inline
removeFromVictimsList(key avatarUuid) {
	integer index;
	while(~(index=getVictimIndex(avatarUuid))) {
		VictimsList=llDeleteSubList(VictimsList, index, index + VICTIMS_LIST_STRIDE - 1);
		llMessageLinked(LINK_SET, RLV_VICTIM_REMOVED, (string)avatarUuid, "");
	}
	if(VictimKey==avatarUuid) {
		changeCurrentVictim(NULL_KEY);
	}
	//if there isn't a victim any more, we don't need a timer
	if(!llGetListLength(VictimsList) && TimerRunning) {
		llSetTimerEvent(0.0);
		TimerRunning=FALSE;
	}
}

// NO pragma inline
changeCurrentVictim(key newVictimKey) {
	if(newVictimKey!=VictimKey) {
		if(newVictimKey==NULL_KEY || ~getVictimIndex(newVictimKey)) {
			//this is a valid key
			VictimKey=newVictimKey;
			llMessageLinked( LINK_SET, UPDATE_CURRENT_VICTIM, (string)VictimKey, "" );
		}
	}
}

// pragma inline
addToDomList(key avatarUuid) {
	removeFromVictimsList(avatarUuid);
	removeFromFreeVictimsList(avatarUuid);
	removeFromDomList(avatarUuid);
	DomList+=[avatarUuid];
}

// NO pragma inline
removeFromDomList(key avatarUuid) {
	integer index;
	while(~(index=getDomIndex(avatarUuid))) {
		DomList=llDeleteSubList(DomList, index, index + DOM_LIST_STRIDE - 1);
	}
}

// NO pragma inline
addToFreeVictimsList(key avatarUuid) {
	removeFromVictimsList(avatarUuid);
	removeFromFreeVictimsList(avatarUuid);
	removeFromDomList(avatarUuid);
	FreeVictimsList+=avatarUuid;
}

// NO pragma inline
removeFromFreeVictimsList(key avatarUuid) {
	integer index;
	while(~(index=getFreeVictimIndex(avatarUuid))) {
		FreeVictimsList=llDeleteSubList(FreeVictimsList, index, index + FREE_VICTIMS_LIST_STRIDE - 1);
	}
}

// pragma inline
addToGrabList(key avatarUuid) {
	if(!~getGrabIndex(avatarUuid)) {
		GrabList+=[avatarUuid, llGetUnixTime() + RLV_ASK_TIMEOUT];
		while (llGetListLength(GrabList) > GRAB_LIST_MAX_ENTRIES * GRAB_LIST_STRIDE) {
			GrabList=llList2List(GrabList, GRAB_LIST_STRIDE, -1);
		}
	}
}

// pragma inline
removeFromGrabList(key avatarUuid) {
	integer index;
	while(~(index=getGrabIndex(avatarUuid))) {
		GrabList=llDeleteSubList(GrabList, index, index + GRAB_LIST_STRIDE - 1);
	}
}

// pragma inline
grabListRemoveTimedOutEntrys() {
	integer currentTime=llGetUnixTime();
	integer length=llGetListLength(GrabList);
	integer index;
	for(; index<length; index+=GRAB_LIST_STRIDE) {
		integer timeout=llList2Integer(GrabList, index + GRAB_LIST_TIMEOUT);
		if(timeout<currentTime) {
			GrabList=llDeleteSubList(GrabList, index, index + GRAB_LIST_STRIDE - 1);
			index-=GRAB_LIST_STRIDE;
			length-=GRAB_LIST_STRIDE;
		}
	}
}

// pragma inline
addToRecaptureList(key avatarUuid, integer timerTime) {
	if(timerTime<0) {
		timerTime=0;
	}
	recaptureListRemoveTimedOutEntrys();
	//slmember1: I don't have an idea how someone could get on the list twice, but to be sure that this will not happen ...
	removeFromRecaptureList(avatarUuid);
	RecaptureList+=[avatarUuid, timerTime, 0];
	while (llGetListLength(RecaptureList) > RECAPTURE_LIST_MAX_ENTRIES * RECAPTURE_LIST_STRIDE) {
		RecaptureList=llList2List(RecaptureList, RECAPTURE_LIST_STRIDE, -1);
	}
}

// pragma inline
removeFromRecaptureList(key avatarUuid) {
	integer index;
	while(~(index=getRecaptureIndex(avatarUuid))) {
		RecaptureList=llDeleteSubList(RecaptureList, index, index + RECAPTURE_LIST_STRIDE - 1);
	}
}

// NO pragma inline
recaptureListRemoveTimedOutEntrys() {
	integer currentTime=llGetUnixTime();
	integer length=llGetListLength(RecaptureList);
	integer index;
	for(; index<length; index+=RECAPTURE_LIST_STRIDE) {
		integer timeout=llList2Integer(RecaptureList, index + RECAPTURE_LIST_TIMEOUT);
		if(timeout && timeout<currentTime) {
			RecaptureList=llDeleteSubList(RecaptureList, index, index + RECAPTURE_LIST_STRIDE - 1);
			index-=RECAPTURE_LIST_STRIDE;
			length-=RECAPTURE_LIST_STRIDE;
		}
	}
}

// NO pragma inline
showMenu( key targetKey, string prompt, list buttons, string menuPath) {
	if(targetKey) {
		llMessageLinked( LINK_SET, DIALOG,
			(string)targetKey
			+ "|" +
			prompt + "\n" + menuPath + "\n"
			+ "|" +
			(string)0
			+ "|" +
			llDumpList2String( buttons, "`" )
			+ "|" +
			llDumpList2String( [ BACKBTN ], "`" )
			+ "|" +
			menuPath
			, MyUniqueId
		);
	}
}

// pragma inline
integer isTimerMenuAllowed(key targetKey) {
	//allowed if:
	//- a victim is selected
	//- and the target of the menu is not a victim, or the timer of the selected victim is already running
	return VictimKey!=NULL_KEY && (!~getVictimIndex(targetKey) || getVictimTimer(VictimKey));
}

// pragma inline
integer isRestrictionsMenuAllowed(key targetKey) {
	//allowed if:
	//- a victim is selected
	//- and the toucher isn't a victim
	//- and the victims RLV is already detected
	//- and the RLV+ RestrictionsMenu Script is available
	return VictimKey!=NULL_KEY && !~getVictimIndex(targetKey) && getVictimRelayVersion(VictimKey) && RlvRestrictionsMenuAvailable;
}


// send rlv commands to the RLV relay, usable for common format (not ping)
// NO pragma inline
sendToRlvRelay(key victim, string rlvCommand, string identifier) {
	if(rlvCommand) {
		if(victim) {
			llSay(RLV_RELAY_CHANNEL,
				conditionalString(llStringLength(identifier), identifier, (string)MyUniqueId) + ","
				+ (string)victim + ","
				+ stringReplace(rlvCommand, "%MYKEY%", (string)llGetKey())
			);
		}
	}
}


// pragma inline
removeVictimTimer(key avatarUuid) {
	integer index=getVictimIndex(avatarUuid);
	if(~index) {
		VictimsList=llListReplaceList(VictimsList, [0], index + VICTIMS_LIST_TIMER, index + VICTIMS_LIST_TIMER);
	}
}

// pragma inline
addTimeToVictim(key avatarUuid, integer time) {
	integer index=getVictimIndex(avatarUuid);
	if(~index) {
		integer thisTime=llGetUnixTime();
		integer oldTime=llList2Integer(VictimsList, index + VICTIMS_LIST_TIMER);
		if(oldTime<thisTime) {
			oldTime=thisTime;
		}
		integer newTime=oldTime + time;
		// if used via menu, almost nobody like the timer to be triggered by substracting time.
		// To stop the timer they can use the Reset button
		if(newTime < thisTime + 30) {
			newTime=thisTime + 30;
		}
		VictimsList=llListReplaceList(VictimsList, [newTime], index + VICTIMS_LIST_TIMER, index + VICTIMS_LIST_TIMER);
		if(!TimerRunning) {
			llSetTimerEvent(1.0);
			TimerRunning=TRUE;
		}
	}
}

// NO pragma inline
integer getVictimTimer(key avatarUuid) {
	integer index=getVictimIndex(avatarUuid);
	if(~index) {
		integer time=llList2Integer(VictimsList, index + VICTIMS_LIST_TIMER) - llGetUnixTime();
		if(time>0) {
			return time;
		}
	}
	return 0;
}

// NO pragma inline
string getVictimTimerString(key avatarUuid) {
	string returnValue="Timer: ";
	integer runningTimeS=getVictimTimer(avatarUuid);
	if(!runningTimeS) {
		return returnValue + TIMER_NO_TIME + NEW_LINE;
	}
	integer runningTimeM=runningTimeS / 60;
	runningTimeS=runningTimeS % 60;
	integer runningTimeH=runningTimeM / 60;
	runningTimeM=runningTimeM % 60;
	integer runningTimeD=runningTimeH / 24;
	runningTimeH=runningTimeH % 24;
	
	return 
		returnValue
		+ conditionalString(runningTimeD, (string)runningTimeD + "d ", "")
		+ llGetSubString("0"+(string)runningTimeH, -2, -1)
		+ ":"
		+ llGetSubString("0"+(string)runningTimeM, -2, -1)
		+ ":"
		+ llGetSubString("0"+(string)runningTimeS, -2, -1)
	;
}

// pragma inline
string conditionalString(integer conditon, string valueIfTrue, string valueIfFalse) {
	string ret=valueIfFalse;
	if(conditon) {
		ret=valueIfTrue;
	}
	return ret;
}


// pragma inline
string getSelectedVictimPromt() {
	return PROMPT_VICTIM + conditionalString(VictimKey!=NULL_KEY, llKey2Name(VictimKey), NO_VICTIM) + NEW_LINE;
}

// pragma inline
integer getVictimRelayVersion(key avatarUuid) {
	integer relayVersion;
	integer index=getVictimIndex(avatarUuid);
	if(~index) {
		relayVersion=llList2Integer(VictimsList, index + VICTIMS_LIST_RELAY);
	}
	return relayVersion;
}

// pragma inline
setVictimRelayVersion(key avatarUuid, integer relayVersion) {
	integer index=getVictimIndex(avatarUuid);
	if(~index) {
		VictimsList=llListReplaceList(VictimsList, [relayVersion], index + VICTIMS_LIST_RELAY, index + VICTIMS_LIST_RELAY);
	}
}

// pragma inline
releaseAvatar(key targetKey) {
	sendToRlvRelay(targetKey, RLV_COMMAND_RELEASE, "");
	addToFreeVictimsList(targetKey);
	removeFromVictimsList(targetKey);
}

// pragma inline
unsitAvatar(key targetKey) {
	sendToRlvRelay(targetKey, "@unsit=y", "");
	llSleep(0.75);
	sendToRlvRelay(targetKey, "@unsit=force", "");
	llSleep(0.75);
	releaseAvatar(targetKey);
}
